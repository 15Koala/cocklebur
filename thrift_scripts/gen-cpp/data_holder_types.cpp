/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "data_holder_types.h"

#include <algorithm>



const char* LogEntry::ascii_fingerprint = "4F357154737171A99AF402A39E295167";
const uint8_t LogEntry::binary_fingerprint[16] = {0x4F,0x35,0x71,0x54,0x73,0x71,0x71,0xA9,0x9A,0xF4,0x02,0xA3,0x9E,0x29,0x51,0x67};

uint32_t LogEntry::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->xid);
          this->__isset.xid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->oper);
          this->__isset.oper = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->content);
          this->__isset.content = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LogEntry::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LogEntry");

  xfer += oprot->writeFieldBegin("xid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->xid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("oper", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->oper);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("content", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->content);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LogEntry &a, LogEntry &b) {
  using ::std::swap;
  swap(a.xid, b.xid);
  swap(a.ts, b.ts);
  swap(a.oper, b.oper);
  swap(a.content, b.content);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

const char* Node::ascii_fingerprint = "FE69B4D3C6F0582846BA70AA4D055D85";
const uint8_t Node::binary_fingerprint[16] = {0xFE,0x69,0xB4,0xD3,0xC6,0xF0,0x58,0x28,0x46,0xBA,0x70,0xAA,0x4D,0x05,0x5D,0x85};

uint32_t Node::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->children.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readSetBegin(_etype3, _size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              std::string _elem5;
              xfer += iprot->readString(_elem5);
              this->children.insert(_elem5);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.children = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->parent);
          this->__isset.parent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ctime);
          this->__isset.ctime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mtime);
          this->__isset.mtime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->data_version);
          this->__isset.data_version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Node::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Node");

  xfer += oprot->writeFieldBegin("children", ::apache::thrift::protocol::T_SET, 1);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->children.size()));
    std::set<std::string> ::const_iterator _iter6;
    for (_iter6 = this->children.begin(); _iter6 != this->children.end(); ++_iter6)
    {
      xfer += oprot->writeString((*_iter6));
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("parent", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->parent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ctime", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ctime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mtime", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->mtime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data_version", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->data_version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Node &a, Node &b) {
  using ::std::swap;
  swap(a.children, b.children);
  swap(a.parent, b.parent);
  swap(a.ctime, b.ctime);
  swap(a.mtime, b.mtime);
  swap(a.data, b.data);
  swap(a.data_version, b.data_version);
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

const char* DataTree::ascii_fingerprint = "6CFB3B13C6E1C5AE61CA1F93297D1D8D";
const uint8_t DataTree::binary_fingerprint[16] = {0x6C,0xFB,0x3B,0x13,0xC6,0xE1,0xC5,0xAE,0x61,0xCA,0x1F,0x93,0x29,0x7D,0x1D,0x8D};

uint32_t DataTree::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->NodeMap.clear();
            uint32_t _size7;
            ::apache::thrift::protocol::TType _ktype8;
            ::apache::thrift::protocol::TType _vtype9;
            xfer += iprot->readMapBegin(_ktype8, _vtype9, _size7);
            uint32_t _i11;
            for (_i11 = 0; _i11 < _size7; ++_i11)
            {
              std::string _key12;
              xfer += iprot->readString(_key12);
              Node& _val13 = this->NodeMap[_key12];
              xfer += _val13.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.NodeMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->xid);
          this->__isset.xid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ephemerals.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _ktype15;
            ::apache::thrift::protocol::TType _vtype16;
            xfer += iprot->readMapBegin(_ktype15, _vtype16, _size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              std::string _key19;
              xfer += iprot->readString(_key19);
              Node& _val20 = this->ephemerals[_key19];
              xfer += _val20.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ephemerals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DataTree::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DataTree");

  xfer += oprot->writeFieldBegin("NodeMap", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->NodeMap.size()));
    std::map<std::string, Node> ::const_iterator _iter21;
    for (_iter21 = this->NodeMap.begin(); _iter21 != this->NodeMap.end(); ++_iter21)
    {
      xfer += oprot->writeString(_iter21->first);
      xfer += _iter21->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xid", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->xid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ephemerals", ::apache::thrift::protocol::T_MAP, 3);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ephemerals.size()));
    std::map<std::string, Node> ::const_iterator _iter22;
    for (_iter22 = this->ephemerals.begin(); _iter22 != this->ephemerals.end(); ++_iter22)
    {
      xfer += oprot->writeString(_iter22->first);
      xfer += _iter22->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DataTree &a, DataTree &b) {
  using ::std::swap;
  swap(a.NodeMap, b.NodeMap);
  swap(a.xid, b.xid);
  swap(a.ephemerals, b.ephemerals);
  swap(a.__isset, b.__isset);
}


