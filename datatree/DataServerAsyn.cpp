// This autogenerated skeleton file illustrates one way to adapt a synchronous
// interface into an asynchronous interface. You should copy it to another
// filename to avoid overwriting it and rewrite as asynchronous any functions
// that would otherwise introduce unwanted latency.

#include "../gen-cpp/DataServ.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/async/TEventServer.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::async;

using boost::shared_ptr;

using namespace  ;

class DataServAsyncHandler : public DataServCobSvIf {
 public:
  DataServAsyncHandler() {
    syncHandler_ = std::auto_ptr<DataServHandler>(new DataServHandler);
    // Your initialization goes here
  }
  virtual ~DataServAsyncHandler();

  void nodeCreate(std::tr1::function<void(int32_t const& _return)> cob, const std::string& path, const bool isBlocked) {
    int32_t _return = 0;
    _return = syncHandler_->nodeCreate(path, isBlocked);
    return cob(_return);
  }

  void nodeDelete(std::tr1::function<void(int32_t const& _return)> cob, const std::string& path) {
    int32_t _return = 0;
    _return = syncHandler_->nodeDelete(path);
    return cob(_return);
  }

  void nodeExist(std::tr1::function<void(bool const& _return)> cob, const std::string& path) {
    bool _return = false;
    _return = syncHandler_->nodeExist(path);
    return cob(_return);
  }

  void getData(std::tr1::function<void(std::string const& _return)> cob, const std::string& path) {
    std::string _return;
    syncHandler_->getData(_return, path);
    return cob(_return);
  }

  void setData(std::tr1::function<void()> cob, const std::string& path, const std::string& data) {
    syncHandler_->setData(path, data);
    return cob();
  }

  void getChildren(std::tr1::function<void(std::vector<Node>  const& _return)> cob, const std::string& path) {
    std::vector<Node>  _return;
    syncHandler_->getChildren(_return, path);
    return cob(_return);
  }

  void getDataTree(std::tr1::function<void(DataTree const& _return)> cob) {
    DataTree _return;
    syncHandler_->getDataTree(_return);
    return cob(_return);
  }

  void getLogEntryList(std::tr1::function<void(std::vector<LogEntry>  const& _return)> cob, const int64_t xid) {
    std::vector<LogEntry>  _return;
    syncHandler_->getLogEntryList(_return, xid);
    return cob(_return);
  }

 protected:
  std::auto_ptr<DataServHandler> syncHandler_;
};

